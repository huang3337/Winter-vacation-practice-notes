# 蓝桥杯嵌入式CT117E-M4实训平台学习



## 1. 点亮LED

1. PD2输出高电平（开启锁存器）;PC8-PC15输出低电平;PD2输出低电平（关闭锁存器，防止后续LCD通过相同引脚影响LED状态）。

   ```
   HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
   HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 , GPIO_PIN_RESET);
   HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
   ```

2. led一端输入高电平，GPIO口需输出低电平才可点亮led



## 2. 利用左移运算符实现点亮特定led

1. ```
   void led_show(uint8_t led, uint8_t mode)
   {
   	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
   	if(mode)
   		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 << (led - 1), GPIO_PIN_RESET);
   	else
   		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8 << (led - 1), GPIO_PIN_SET);
   	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
   }
   ```

2. GPIO_PIN_8的二进制编码为0000 0001 0000 0000，

   GPIO_PIN_9的二进制编码为0000 0010 0000 0000，

   ……以此类推到GPIO_PIN_15。

   因此通过改变led的数使GPIO_PIN_8二进制编码左移成为相应的地址，达到控制特定GPIO口的目的。

   

## 3. 按键

1. 上拉输入：按键没有按下时，输入得到高电平；

    	   	按键按下时，输入得到低电平；

   下拉输入相反。

2. 按键控制LED亮灭：

   ```
   void key_scan()
   {
   	B1_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0);
   	B2_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1);
   	B3_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2);
   	B4_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);
   	
   
   if(B1_state == 0 && B1_last_state == 1) //按键B1按下
   {
   	led_show(1,1);
   }
   
   if(B2_state == 0 && B2_last_state == 1) //按键B2按下
   {
   	led_show(1,0);
   }
   
   if(B3_state == 0 && B3_last_state == 1) //按键B3按下
   {
   	led_show(2,1);
   }
   
   if(B4_state == 0 && B4_last_state == 1) //按键B4按下
   {
   	led_show(2,0);
   }
   
   B1_last_state = B1_state;
   B2_last_state = B2_state;
   B3_last_state = B3_state;
   B4_last_state = B4_state;
   
   }
   ```

   

## 4. LCD显示

1. 在主循环前要对LCD进行初始化和各种设置

   ```
     LCD_Init();//初始化LCD
     LCD_Clear(Black);//整块屏幕设定为。。。
     LCD_SetBackColor(Black);//显示文字背景为。。。
     LCD_SetTextColor(White);//设置文字颜色。。。
   ```

2. 结合 3 中的按键使count自增自减可以实现LCD显示变量

   ```
   int count = 0;
   char text[20];//这块屏幕只能显示20个字符、
   
   void lcd_show()
   {
   	sprintf(text, "       test     ");
   	LCD_DisplayStringLine(Line0, (uint8_t *)text);
   	sprintf(text, "       count: %d ",  count);
   	LCD_DisplayStringLine(Line3, (uint8_t *)text);
   }
   ```



## 5.LED与LCD引脚冲突问题

值得注意的是，本实验板的LCD与LED有引脚冲突，同样使用了PC8-PC15引脚。解决方法如下：

1. 由于cubemx中配置GPIO口时开启了锁存器，在初始化LCD的操作前添加以下代码，防止初始化LCD的操作影响LED的状态

```
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
  //关闭锁存器，让后面的LCD操作不会改变LED的状态
  
  LCD_Init();//初始化LCD
  LCD_Clear(Black);//整块屏幕设定为。。。
  LCD_SetBackColor(Black);//显示文字背景为。。。
  LCD_SetTextColor(White);//设置文字颜色。。。
```

2. 后续主循环中同样可能有调整LCD的代码，为了不使LCD控制代码影响相应IO口对LED的控制，可以在每个会产生影响的函数定义中加入以下代码：

   ```
   uint16_t temp = GPIOC->ODR;
   
   ……
   
   GPIOC->ODR = temp;
   ```

   如：

   ```
   void LCD_Clear(u16 Color)
   {	
       u32 index = 0;
       LCD_SetCursor(0x00, 0x0000);
       LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
       for(index = 0; index < 76800; index++)
       {
           LCD_WriteRAM(Color);
       }
   }
   ```

   将会被改为：

   ```
   void LCD_Clear(u16 Color)
   {	
       uint16_t temp = GPIOC->ODR;
       u32 index = 0;
       LCD_SetCursor(0x00, 0x0000);
       LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
       for(index = 0; index < 76800; index++)
       {
           LCD_WriteRAM(Color);
       }
   	GPIOC->ODR = temp;
   }
   ```

   这样达到在调用这类函数产生影响前暂时储存PC端的输出状态，在使用完函数后让PC端继承原先状态，保证每次调用LCD控制函数时都不会改变IO口原先的输出状态。

   

## 